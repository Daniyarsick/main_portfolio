<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Просмотр файлов - Портфолио</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>

<body>
    <div class="container">
        <header>
            <a href="#" id="back-btn" class="back-link">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M10 19l-7-7m0 0l7-7m-7 7h18" />
                </svg>
                Назад
            </a>
            <h1 id="folder-title">Загрузка...</h1>
            <p class="subtitle" id="folder-subtitle">Список файлов</p>
        </header>

        <main class="file-grid" id="file-list">
            <!-- Files will be injected here -->
        </main>
    </div>

    <script src="files.js"></script>
    <script>
        const GITHUB_OWNER = 'Daniyarsick';
        const GITHUB_REPO = 'main_portfolio';
        const GITHUB_BRANCH = 'main';

        function encodePathSegments(path) {
            return String(path)
                .split('/')
                .filter(Boolean)
                .map(seg => encodeURIComponent(seg))
                .join('/');
        }

        // Относительный путь для GitHub Pages (с правильным URL-encoding)
        function toPagesHref(repoPath) {
            return './' + encodePathSegments(repoPath);
        }

        // GitHub Blob viewer (лучше для PDF/LFS и крупных файлов)
        function toGitHubBlobHref(repoPath) {
            return `https://github.com/${encodeURIComponent(GITHUB_OWNER)}/${encodeURIComponent(GITHUB_REPO)}/blob/${encodeURIComponent(GITHUB_BRANCH)}/${encodePathSegments(repoPath)}`;
        }

        function getFileType(filename) {
            const idx = filename.lastIndexOf('.');
            if (idx === -1) return 'file';
            return filename.slice(idx + 1).toLowerCase();
        }

        async function githubFetchJson(pathnameWithQuery) {
            const url = `https://api.github.com${pathnameWithQuery}`;
            const response = await fetch(url, {
                headers: {
                    'Accept': 'application/vnd.github+json'
                }
            });

            if (!response.ok) {
                const text = await response.text().catch(() => '');
                throw new Error(`GitHub API error ${response.status}: ${text || response.statusText}`);
            }

            return response.json();
        }

        async function githubListContents(repoPath) {
            const encoded = encodePathSegments(repoPath);
            return githubFetchJson(`/repos/${encodeURIComponent(GITHUB_OWNER)}/${encodeURIComponent(GITHUB_REPO)}/contents/${encoded}?ref=${encodeURIComponent(GITHUB_BRANCH)}`);
        }

        function buildViewerHref(pathParam) {
            return `viewer.html?path=${encodeURIComponent(pathParam)}`;
        }

        function splitPath(pathParam) {
            return String(pathParam)
                .split('/')
                .map(s => s.trim())
                .filter(Boolean);
        }

        function parentPath(pathParam) {
            const parts = splitPath(pathParam);
            if (parts.length <= 1) return null;
            return parts.slice(0, -1).join('/');
        }

        function entriesFromFileData(pathParam) {
            if (typeof fileData === 'undefined') return null;

            const parts = splitPath(pathParam);
            const course = parts[0];
            const subject = parts[1];
            if (!course || !subject) return null;

            const subjectFiles = fileData?.[course]?.[subject];
            if (!Array.isArray(subjectFiles)) return null;

            const base = parts.join('/');
            const basePrefix = base + '/';

            const folderSet = new Set();
            const files = [];

            for (const f of subjectFiles) {
                const repoPath = String(f?.path || '').startsWith('./') ? String(f.path).slice(2) : String(f?.path || '');
                if (!repoPath) continue;
                if (!repoPath.startsWith(basePrefix)) continue;

                const rest = repoPath.slice(basePrefix.length);
                const restParts = rest.split('/').filter(Boolean);
                if (restParts.length === 0) continue;

                if (restParts.length === 1) {
                    files.push({
                        name: f.name,
                        repoPath,
                        type: f.type || getFileType(f.name),
                        size: typeof f.size === 'number' ? f.size : 0
                    });
                } else {
                    folderSet.add(restParts[0]);
                }
            }

            const dirs = Array.from(folderSet).map(name => ({
                name,
                repoPath: basePrefix + name
            }));

            return { dirs, files };
        }

        function iconForType(type) {
            if (['jpg', 'png', 'jpeg', 'gif', 'svg'].includes(type)) return 'fa-file-image';
            if (type === 'pdf') return 'fa-file-pdf';
            if (['doc', 'docx'].includes(type)) return 'fa-file-word';
            if (['xls', 'xlsx'].includes(type)) return 'fa-file-excel';
            if (['ppt', 'pptx'].includes(type)) return 'fa-file-powerpoint';
            if (['zip', 'rar', '7z'].includes(type)) return 'fa-file-archive';
            if (['mp4', 'avi', 'mkv', 'mov'].includes(type)) return 'fa-file-video';
            if (['mp3', 'wav', 'ogg'].includes(type)) return 'fa-file-audio';
            if (['py', 'js', 'html', 'css', 'cpp', 'java', 'c', 'h'].includes(type)) return 'fa-file-code';
            if (['txt', 'md'].includes(type)) return 'fa-file-alt';
            return 'fa-file';
        }

        document.addEventListener('DOMContentLoaded', async () => {
            const params = new URLSearchParams(window.location.search);
            const pathParam = params.get('path'); // e.g., "1 курс/Дискретная математика"

            if (!pathParam) {
                document.getElementById('folder-title').textContent = "Ошибка: Путь не указан";
                return;
            }

            const parts = splitPath(pathParam);
            const course = parts[0];
            const subject = parts[1];
            const currentTitle = parts.length > 0 ? parts[parts.length - 1] : pathParam;

            document.getElementById('folder-title').textContent = currentTitle;
            document.getElementById('folder-subtitle').textContent = pathParam;

            // Set back button
            const backBtn = document.getElementById('back-btn');
            const parent = parentPath(pathParam);
            if (parent && parts.length > 2) {
                backBtn.href = buildViewerHref(parent);
            } else {
                if (course === "1 курс") backBtn.href = "course1.html";
                else if (course === "2 курс") backBtn.href = "course2.html";
                else if (course === "3 курс") backBtn.href = "course3.html";
                else if (course === "4 курс") backBtn.href = "course4.html";
                else backBtn.href = "index.html";
            }

            const fileList = document.getElementById('file-list');
            fileList.innerHTML = '<p class="empty-msg">Загрузка…</p>';

            let dirs = [];
            let files = [];
            try {
                const entries = await githubListContents(pathParam);
                if (!Array.isArray(entries)) throw new Error('Unexpected GitHub API response');

                dirs = entries
                    .filter(e => e && e.type === 'dir' && e.path && e.name)
                    .map(e => ({ name: e.name, repoPath: e.path }));

                files = entries
                    .filter(e => e && e.type === 'file' && e.path && e.name)
                    .map(e => ({
                        name: e.name,
                        repoPath: e.path,
                        type: getFileType(e.name),
                        size: typeof e.size === 'number' ? e.size : 0
                    }));
            } catch (error) {
                const fallback = entriesFromFileData(pathParam);
                if (fallback) {
                    dirs = fallback.dirs;
                    files = fallback.files;
                } else {
                    fileList.innerHTML = '<p class="empty-msg">Не удалось загрузить файлы</p>';
                    // eslint-disable-next-line no-console
                    console.error(error);
                    return;
                }
            }

            if ((!dirs || dirs.length === 0) && (!files || files.length === 0)) {
                fileList.innerHTML = '<p class="empty-msg">Папка пуста</p>';
                return;
            }

            dirs.sort((a, b) => String(a.name).localeCompare(String(b.name), 'ru'));

            // Sort: PDFs first, then others
            files.sort((a, b) => {
                if (a.type === 'pdf' && b.type !== 'pdf') return -1;
                if (a.type !== 'pdf' && b.type === 'pdf') return 1;
                return String(a.name).localeCompare(String(b.name), 'ru');
            });

            fileList.innerHTML = '';

            dirs.forEach(dir => {
                const folderCard = document.createElement('a');
                folderCard.href = buildViewerHref(dir.repoPath);
                folderCard.className = 'file-card';
                folderCard.target = '_self';

                folderCard.innerHTML = `
                    <div class="file-icon"><i class="fas fa-folder"></i></div>
                    <div class="file-info">
                        <div class="file-name">${dir.name}</div>
                        <div class="file-size">Папка</div>
                    </div>
                `;
                fileList.appendChild(folderCard);
            });

            files.forEach(file => {
                const fileCard = document.createElement('a');
                const fileType = file.type || getFileType(file.name);
                const fileSize = typeof file.size === 'number' ? file.size : 0;

                // PDF и большие файлы открываем через GitHub (из-за LFS/ограничений Pages)
                if (fileType === 'pdf') {
                    fileCard.href = toGitHubBlobHref(file.repoPath);
                } else if (['mp4', 'avi', 'mp3'].includes(fileType) && fileSize > 50000000) {
                    fileCard.href = toGitHubBlobHref(file.repoPath);
                } else {
                    fileCard.href = toPagesHref(file.repoPath);
                }

                fileCard.className = 'file-card';
                fileCard.target = '_blank';

                const iconClass = iconForType(fileType);
                fileCard.innerHTML = `
                    <div class="file-icon"><i class="fas ${iconClass}"></i></div>
                    <div class="file-info">
                        <div class="file-name">${file.name}</div>
                        <div class="file-size">${formatSize(fileSize)}</div>
                    </div>
                `;
                fileList.appendChild(fileCard);
            });
        });

        function formatSize(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
    </script>
</body>

</html>